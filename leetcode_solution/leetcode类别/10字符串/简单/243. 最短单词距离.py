'''问题描述
给定一个词语列表和两个词语 word1和 word2, 返回这两个词语在列表中的最短距离.

例如, 假设 words=["practice","makes","perfect","coding","makes"]:

给定 word1=“coding”,word2=“practice”, 返回 3

给定 word1="makes",word2="coding", 返回 `1

注意:

可以假设 word1不等于 word2, 并且 word1和 word2都在列表中.

解题思路
方法1

最简单的方法是: 使用两个数组分别存储 word1和 word2出现的位置, 然后再两两进行比较, 获取最小值即可.

但是很明显时间复杂度为 O(n*n), 其中 n为 words数组的长度, 主要花费在两两比较的地方, 而空间复杂度为 O(n), 主要是两个比较数组.

方法2

上面说到两两比较需要花费大量时间, 那么我们可以考虑一下能否直接进行比较呢? 答案是可以的. 使用两个变量分别存储 word1和 word2上次出现的位置, 每次遇到新的匹配时, 直接更新即可, 不用保存之前的值(因为即使后面再遇到另外单词的匹配值时, 肯定是当前的会距离更近), 然后根据情况更新结果值即可.

此时, 时间复杂度为 O(n), 空间复杂度为 O(1).
方法3

进一步地, 其实不需要每一次遍历都更新结果值, 只有在遇到更新索引的时候才可能会变更. 因此, 只需要一个变量 index来存储遇到的上一个匹配值的索引即可. 每次遇到 word1或者 word2的时候, 需要判断一下 words[index]与当前值是否相等, 如果相等的话, 直接更新 index, 如果不相等, 则判断一下是否需要更新结果值, 然后再更新 index.
'''
# code：https://mp.weixin.qq.com/s/4ai5sh-JH3yLtsn9EnjaVA