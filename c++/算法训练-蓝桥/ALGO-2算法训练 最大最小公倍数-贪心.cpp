/*
问题描述
已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。
输入格式
输入一个正整数N。
输出格式
输出一个整数，表示你找到的最小公倍数。
样例输入
9
样例输出
504

*/


#include<iostream>
using namespace std;

int main() {
	long long n, ans;
	while(cin >> n) {		
		if(n <= 2) {
			ans = n;
		} 
		else if(n % 2) {
			ans = n * (n - 1) * (n - 2);
		}
		else {
			if(n%3) ans = n * (n-1) * (n-3);
			else ans=(n-1) * (n-2) * (n-3);
		}
		cout << ans << endl;
	}
	return 0;
}



/*思路：若n 和 n-1和n-2 三个数 两两互质的话，那么结果就是这三个数的积。
根据数论知识：任意大于1的两个相邻的自然数都是互质的.
我们可以知道，当n是奇数时，n 和n-2都是奇数，n-1是偶数,那么他们三个的公约数肯定不是2,而因为这三个数是连续的，所以大于2的数都不可能成为他们或其中任意两个数的公约数了.结果就是他们三个的乘积.
而当n为偶数时，n*(n-1)*(n-2)肯定不行了，因为n和n-2都是偶数，那么只能将n-2改成n-3，即n*(n-1)*(n-3),如果这三个数两两互质那么肯定就是结果了.
但是为n和n-3相差3,所以当其中一个数能被3整除时，另一个肯定也可以.而当其中一个不可以时，另一个肯定也不可以.而因为n为偶数,n-3为奇数，所以2不可能成为他俩的公因子。对于大于3的数，肯定就都不可能成为这三个数或者其中任意两个数的公约数了.因此只需再对3进行判断：
如果n能整除3，那么，n*(n-1)*(n-3)就肯定不行了，因为n和n-3有了公约数3，结果肯定小了，那么就只能继续判下一个即n*(n-1)*(n-4)而这样n-4又是偶数，不行继续下一个n*(n-1)*(n-5) = n^3 -6*n^2 + 5*n 而如果这个可以 那个其值肯定要小于(n-1)*(n-2)*(n-3) = n^3 -6*n^2+11n-6(对于n>1来说都成立),而(n-1)*(n-2)*(n-3)由上一个奇数结论可知是一个符合要求的，因此到n-5就不用判断了。直接选答案为(n-1)*(n-2)*(n-3)；
*/
